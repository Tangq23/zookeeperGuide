#### zookeeper基本数据类型

* zookeeper是一个树形结构,类似于前端开发中的 tree.js 组件;

  ![image.png](https://upload-images.jianshu.io/upload_images/15181329-4e9ed23f9c1ee2fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



* zk的数据模型也可以理解为 linux/unix 的文件目录:/usr/local

* 每一个节点都称之为 znode,它可以有子节点,也可以有数据

  > 子节点: 就是父目录下的一个子目录,在 zk中称之为节点,每一个节点中都有一些相应的数据,就像目录下有一些文件数据一样

* 每个节点分为临时节点和永久节点,临时节点在客户端断开后消失

  > 永久节点：其实就是一个持久化的过程，我们存了一些数据，只有人为的情况在才会删除	如是session超时或者是session丢失，数据还是会一直存在的。临时节点生命周期依赖创建它的会话，一旦会话结束，临时节点将会被删除。临时节点不允许有子节点。

* 每个zk节点都是有各自的版本号，可以通过命令行来显示节点信息；

  > 节点的信息其实就是节点的详情，详情中包含了一些版本号，版本号是累加的，每当节点中的数据发生变化，版本号就会累加（乐观锁）

* 删除/修改过时节点，版本号不匹配则会报错

  > 例如我们在查询某一个节点的时候，比如说它的节点是1，经过两个人进行删除或者修改之后，那么它的节点会由1变为2，在变为3，此时我们需要去修改或者删除这个节点，那么删除这个节点的时候，我们传入的版本号是一个老的版本号，那么这个时候就会报一个版本号不匹配的异常，这也是在数据库中是使用乐观锁的一种表现

* 每一个zk节点存储的数据不宜过大，几k即可(官方推荐)；

* 节点是可以设置权限acl ,可以通过权限来限定用户的访问

  > acl:权限控制列表，后续会讲到；

#### zookeeper应用场景

* Master选举

  > 在分布式系统中，Master往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权，如在读写分离的应用场景中，客户端的写请求往往是由Master来处理，或者其常常处理一些复杂的逻辑并将处理结果同步给其他系统单元。利用Zookeeper的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即Zookeeper将会保证客户端无法重复创建一个已经存在的数据节点。
  >
  > 　　首先创建/master_election/2019-07-05节点，客户端集群每天会定时往该节点下创建临时节点，如/master_election/2019-07-05/binding，这个过程中，只有一个客户端能够成功创建，此时其变成master，其他节点都会在节点/master_election/2019-07-05上注册一个子节点变更的Watcher，用于监控当前的Master机器是否存活，一旦发现当前Master挂了，其余客户端将会重新进行Master选举。
  >
  > 这也就是所谓的首脑模式，从而保证我们的集群是高可用的；

![image.png](https://upload-images.jianshu.io/upload_images/15181329-16cd945fc69b1932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

https://www.jianshu.com/p/2e970fe35c3f>

